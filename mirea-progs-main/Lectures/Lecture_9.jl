md"""
# Элементы функционального программирования

## Функции - как объекты 1-го класса
"""
x = 0

s = sin  # <: Function 

md"""
Пусть, например, мы хотим перемещать робота в заданном направлении до тех пор, пока не наступит некоторое событие,
выраженное соответствующим условием.

Это реализуется следующей функцией:
"""

function movements!(condition::Function, r, side)
    n=0
    while !condition(r)
        move!(r,side)
        n+=1
    end
    return n
end

#Теперь эту функцию можно вызывать, например, так:

movements!(isborder, r, side)

md"""
## Анонимные функции
Анонимные функции представляют собой функциональные значения (<: Function) без имени
 (подобно тому, как бывают значения типа Int без имени)

Например:

condition = robot -> !isborder(robot) 

Здесь переменной condition присвоено некоторое функциональное значение (значение анонимной функции).

Другие римеры:

f = x -> 2x

f(2)
4

(x -> 2x)(3)
6

f2= (x,y) -> x^2+y^2

f2(2,3)
13

g= _ -> 1

g(1)
1

g(2)
1

g(3)
1

g()
ERROR

g(1,2)
ERROR

g2 = (_,_) -> 1

g2(1,2)
1


Анонимные функции часто также называю ЛЯМБДА- функциями 
(это название пришло из соответствующего раздела математической логики, из так называемого лямбда-исчислниия) 

В языке Python, например, определение фанкции

x -> 2x

выглядело бы так:

lambda x: 2*x

При этом, однако, в отличие от языка Python, в языке Julia нет тех сильных ограничений, которые есть в языке Python на вид выражения, 
определяющее анонимную функцию.

## Функции высшего порядка

Функция называется  функцией высшего порядка, если она имеет хотя бы один аргумент функционального типа 
или если она возвращает значение функционального типа.

Пример встроенной функции высшего порядка - map

julia> map(x->x^2, [1,2,3,4])
4-element Vector{Int64}:
  1
  4
  9
 16

julia> map(x->x^2, (1,2,3,4))
(1, 4, 9, 16)

julia> map(sin, (1,2,3,4))
(0.8414709848078965, 0.9092974268256817, 0.1411200080598672, -0.7568024953079282)


## do-синтаксис

julia> map([1,2,3,4,5]) do x
    x^2
end
5-element Vector{Int64}:
1
4
9
16
25


julia> map([1,2,3,4,5]) do _
    0
end
5-element Vector{Int64}:
0
0
0
0
0


do-синтаксис применим не только к встоеннной функции map, но и к любой другой, у котрой первый аргумент
имеет функциональный тип.

Этот синтаксис просто позволяет определить фактическое значение этого параметра в этой компактной конструкци,
без того, чтобы определять эту функцию отдельно стандартным образом.


## Пример функции высшего порядка, возвращающей функциональное значение. Понятие замыкания.

julia> function g(a)
           return x -> a*x # возвращается функциональное значение (функция)
       end
g (generic function with 1 method)


julia> h = g(2)
#33 (generic function with 1 method)

julia> h(2)
4

julia> h(3)
6

julia> h = g(3)
#33 (generic function with 1 method)

julia> h(3)
9

## Примеры практического использования функций высшего порядка.


Ранее были у на  такие функции

    movements!(robot, side) # перемещает робота "до упора" в заданном направлении и возвращает число сделанных "шагов"

    movements!(robot, side, num_steps) # делает num_steps шагов в заданном напралении

Их можно было бы дополнить ещё двумя методами - двумя функциями высшего порядка:

    movements!(condition::Function, robot, side) 

и, соответственно,

    movements!(condition::Function, robot, side, num_steps)

где в в обоих случаях через функциональный параметр condition в функцию передаётся условие, 
только и только при выполнении которого робот должен перемещаться.
При этом во втором случае через параметр num_steps передается еще наибольшее число шагов, которое робот может 
сделать в заданном направлении (даже если условие, определяемое condition все время выполняется).

Функции высшего порядка movements! (новые методы функции movements!, в терминологии языка julia) могут быть
реализованы так, что функция condition будет иметь один аргумент (robot), или, в другом варианте реализации,
вообще не будут иметь аргументов.

### Варианты реализации функции movements!(condition::Function, robot, side) 

1-вариант
"""
"""
movements!(condition::Function, robot, side) 

-- возвращает число шагов, сделанных "до тех пор, пока выпоняется условие condition"

-- condition - функция одного аргумента (типа робот), возвращающая логическое значение
"""
function movements!(condition::Function, r, side) 
    
    while condition(r) == true
        move!(r,side)
    end
end

# Примеры использования этой функции:


r=Ribot() # тип робота мог бы быть и другим

movements!(r->!isborder(r,Ost), r, Ost) # - это вызов функции

movements!(r, Ost) do robot
    robot->!isborder(robot, Ost)
end # - это вызов функции с использованием do-синтаксиса


movements!(ismarker, r, Ost)

movements!(robot -> ismarker(robot), r, Ost)

md"""
2-ой вариант реализации той же функции movements!(condition::Function, r, side) 
(наверное, более предпочтительный)
"""

"""
movements!(condition::Function, robot, side) 

-- возвращает число шагов, сделанных "до тех пор, пока выпоняется условие condition"

-- condition - функция без аргументов, возвращающая логическое значение
"""
function movements!(condition::Function, robot, side) 
    #  число шагов, сделанных "до тех пор, пока выпоняется условие condition"
    while condition() == true
        move!(robot, side)
    end
end

# Пример использования так определенной функции movements!:

r=Ribot() # тип робота мог бы быть и другим

movements!(() -> !isborder(r, Ost), r, Ost) # - это вызов функции

movements!(r, Ost) do
    robot->!isborder(r, Ost)
end # - это вызов функции с использованием do-синтаксиса

md"""
### Реализация функции movements!(condition::Function, robot, side)

Определим эту функцию (обобщенную), так, чтобы она перемещала робота в заданном направлении не более чем на 
num_steps шагов, пока выпоняется условие condition()==true". При этом она будет возвращать число сделанных роботом
"шагов" до своей остановки.
"""

"""
movements!(condition::Function, robot, side, num_steps) 

-- делает не более чем num_steps шагов в заданном направлении, пока выпоняется условие condition()==true", 
и возвращает число сделанных шагов

-- condition - функция без аргументов, возвращающая логическое значение
"""
function movements!(condition::Function, r, side, num_steps)
    n = 0
    for _ in 1:num_steps
        if condition() == true
            move!(r, side)
            n += 1
        else
            return n 
        end
    end  
    return n 
end

md""" 
Такая функция была бы удобной, например, для решения задачи, в которой требуется
на неограниченном поле нати маркер (была у нас такая задача).

Так же её можно было бы использовать для реализации функции try_move!(robot, side::HorizonSide). 

Рассмотрим ещё примеры некоторых других полезных (обобщенных) функций высшего порядка, которыми стоило бы 
поплнить нашу библиотеку функций.

1. Функция 

    shuttle(condtion::Function, robot, side)
    
перемещающая робота взад-вперед (челноком, as shuttle) с увелисением амплитуды перемещений
до тех пор, пока не будет выполено заданное условие, 
где side - начальное направление, 

2. Функция, перемещающая робота змейкой 

    snake(condition::Function, robot, side::NTuple{HorizonSide})

до тех пор, пока не будет выполено заданное условие condition()==true, 
где side - пара направлений, определяющих траекторию змейки.


3. Функция, перемещающая робота по спирали 

    spiral(condition::Function, robot, side)

до тех пор, пока не будет выполено заданное условие condition()==true, 
где side - начальное направление.
"""